# 3-1. デプロイメントパイプライン

TerraformとCI/CDパイプラインの連携方法を説明します。

## 3-1-1. CI/CDパイプラインとの連携

### GitHub Actionsとの連携

GitHub ActionsでTerraformを実行します。

```yaml
# .github/workflows/terraform.yml
name: Terraform

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  terraform:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.6.0
      
      - name: Terraform Init
        run: terraform init
      
      - name: Terraform Format Check
        run: terraform fmt -check
      
      - name: Terraform Validate
        run: terraform validate
      
      - name: Terraform Plan
        run: terraform plan -out=tfplan
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      
      - name: Terraform Apply
        if: github.ref == 'refs/heads/main' && github.event_name == 'push'
        run: terraform apply -auto-approve tfplan
```

### GitLab CI/CDとの連携

GitLab CI/CDでTerraformを実行します。

```yaml
# .gitlab-ci.yml
stages:
  - validate
  - plan
  - apply

terraform:validate:
  stage: validate
  image: hashicorp/terraform:1.6.0
  script:
    - terraform init
    - terraform fmt -check
    - terraform validate
  only:
    - merge_requests

terraform:plan:
  stage: plan
  image: hashicorp/terraform:1.6.0
  script:
    - terraform init
    - terraform plan -out=tfplan
  artifacts:
    paths:
      - tfplan
  only:
    - merge_requests

terraform:apply:
  stage: apply
  image: hashicorp/terraform:1.6.0
  script:
    - terraform init
    - terraform apply -auto-approve tfplan
  only:
    - main
  when: manual
```

### Jenkinsとの連携

JenkinsでTerraformを実行します。

```groovy
// Jenkinsfile
pipeline {
    agent any
    
    environment {
        AWS_ACCESS_KEY_ID = credentials('aws-access-key-id')
        AWS_SECRET_ACCESS_KEY = credentials('aws-secret-access-key')
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }
        
        stage('Terraform Init') {
            steps {
                sh 'terraform init'
            }
        }
        
        stage('Terraform Validate') {
            steps {
                sh 'terraform validate'
            }
        }
        
        stage('Terraform Plan') {
            steps {
                sh 'terraform plan -out=tfplan'
            }
        }
        
        stage('Terraform Apply') {
            when {
                branch 'main'
            }
            steps {
                input message: 'Apply changes?'
                sh 'terraform apply -auto-approve tfplan'
            }
        }
    }
}
```

### CircleCIとの連携

CircleCIでTerraformを実行します。

```yaml
# .circleci/config.yml
version: 2.1

jobs:
  terraform:
    docker:
      - image: hashicorp/terraform:1.6.0
    steps:
      - checkout
      - run:
          name: Terraform Init
          command: terraform init
      - run:
          name: Terraform Validate
          command: terraform validate
      - run:
          name: Terraform Plan
          command: terraform plan -out=tfplan
      - persist_to_workspace:
          root: .
          paths:
            - tfplan

  apply:
    docker:
      - image: hashicorp/terraform:1.6.0
    steps:
      - checkout
      - attach_workspace:
          at: .
      - run:
          name: Terraform Apply
          command: terraform apply -auto-approve tfplan

workflows:
  version: 2
  terraform:
    jobs:
      - terraform
      - apply:
          requires:
            - terraform
          filters:
            branches:
              only: main
```

### パイプラインの設計

#### 基本的なフロー

1. **コードチェックアウト**
2. **Terraform Init**
3. **Terraform Format Check**
4. **Terraform Validate**
5. **Terraform Plan**
6. **承認（本番環境の場合）**
7. **Terraform Apply**

#### 環境ごとの分離

```yaml
# 開発環境: 自動適用
# ステージング環境: 手動承認
# 本番環境: 複数承認が必要
```

## 3-1-2. CodePipeline、CodeBuildとの統合

### CodePipelineパイプラインの作成

CodePipelineでTerraformを実行します。

```hcl
resource "aws_codepipeline" "terraform" {
  name     = "terraform-pipeline"
  role_arn = aws_iam_role.codepipeline.arn
  
  artifact_store {
    location = aws_s3_bucket.artifacts.bucket
    type     = "S3"
  }
  
  stage {
    name = "Source"
    
    action {
      name             = "Source"
      category         = "Source"
      owner            = "AWS"
      provider         = "CodeStarSourceConnection"
      version          = "1"
      output_artifacts = ["source_output"]
      
      configuration = {
        ConnectionArn    = aws_codestarconnections_connection.github.arn
        FullRepositoryId = "username/repository"
        BranchName       = "main"
      }
    }
  }
  
  stage {
    name = "Build"
    
    action {
      name             = "TerraformBuild"
      category         = "Build"
      owner            = "AWS"
      provider         = "CodeBuild"
      input_artifacts  = ["source_output"]
      output_artifacts = ["build_output"]
      version          = "1"
      
      configuration = {
        ProjectName = aws_codebuild_project.terraform.name
      }
    }
  }
  
  stage {
    name = "Deploy"
    
    action {
      name            = "TerraformApply"
      category        = "Build"
      owner           = "AWS"
      provider        = "CodeBuild"
      input_artifacts = ["build_output"]
      version         = "1"
      
      configuration = {
        ProjectName = aws_codebuild_project.terraform_apply.name
      }
    }
  }
}
```

### CodeBuildプロジェクトの作成

Terraformを実行するCodeBuildプロジェクトを作成します。

```hcl
resource "aws_codebuild_project" "terraform" {
  name          = "terraform-build"
  build_timeout = 60
  service_role  = aws_iam_role.codebuild.arn
  
  artifacts {
    type = "CODEPIPELINE"
  }
  
  environment {
    compute_type                = "BUILD_GENERAL1_SMALL"
    image                       = "hashicorp/terraform:1.6.0"
    type                        = "LINUX_CONTAINER"
    image_pull_credentials_type = "SERVICE_ROLE"
    
    environment_variable {
      name  = "AWS_DEFAULT_REGION"
      value = "ap-northeast-1"
    }
  }
  
  source {
    type = "CODEPIPELINE"
  }
}
```

### Terraformのビルド仕様

`buildspec.yml`を作成します。

```yaml
version: 0.2

phases:
  install:
    commands:
      - echo "Installing Terraform..."
      - terraform version
      
  pre_build:
    commands:
      - echo "Terraform Init..."
      - terraform init
      
  build:
    commands:
      - echo "Terraform Format Check..."
      - terraform fmt -check
      - echo "Terraform Validate..."
      - terraform validate
      - echo "Terraform Plan..."
      - terraform plan -out=tfplan
      
  post_build:
    commands:
      - echo "Build completed"
      
artifacts:
  files:
    - tfplan
    - '**/*'
```

### デプロイステージの設定

デプロイ用のCodeBuildプロジェクトを作成します。

```hcl
resource "aws_codebuild_project" "terraform_apply" {
  name          = "terraform-apply"
  build_timeout = 60
  service_role  = aws_iam_role.codebuild.arn
  
  artifacts {
    type = "CODEPIPELINE"
  }
  
  environment {
    compute_type = "BUILD_GENERAL1_SMALL"
    image        = "hashicorp/terraform:1.6.0"
    type         = "LINUX_CONTAINER"
  }
  
  source {
    type = "CODEPIPELINE"
  }
}
```

### 承認ステップの追加

本番環境へのデプロイ前に承認を追加します。

```hcl
resource "aws_codepipeline" "terraform" {
  # ... 既存の設定 ...
  
  stage {
    name = "Approval"
    
    action {
      name     = "ManualApproval"
      category = "Approval"
      owner    = "AWS"
      provider = "Manual"
      version  = "1"
    }
  }
  
  stage {
    name = "Deploy"
    # ... デプロイアクション ...
  }
}
```

## 3-1-3. デプロイ戦略

### ブルー・グリーンデプロイ

新しい環境を構築してから切り替えます。

```hcl
# ブルー環境（既存）
resource "aws_instance" "blue" {
  count = 2
  # ...
  tags = {
    Environment = "blue"
  }
}

# グリーン環境（新規）
resource "aws_instance" "green" {
  count = 2
  # ...
  tags = {
    Environment = "green"
  }
}

# ALBで切り替え
resource "aws_lb_target_group" "green" {
  name = "green-tg"
  # ...
}

resource "aws_lb_listener_rule" "green" {
  listener_arn = aws_lb_listener.main.arn
  priority     = 100
  
  action {
    type             = "forward"
    target_group_arn = aws_lb_target_group.green.arn
  }
  
  condition {
    path_pattern {
      values = ["/green/*"]
    }
  }
}
```

### カナリアデプロイ

段階的にトラフィックを移行します。

```hcl
# メイン環境（90%のトラフィック）
resource "aws_lb_listener_rule" "main" {
  priority = 100
  
  action {
    type             = "forward"
    target_group_arn = aws_lb_target_group.main.arn
  }
  
  condition {
    http_request_method {
      values = ["GET", "POST"]
    }
  }
}

# カナリア環境（10%のトラフィック）
resource "aws_lb_listener_rule" "canary" {
  priority = 200
  
  action {
    type             = "forward"
    target_group_arn = aws_lb_target_group.canary.arn
  }
  
  condition {
    http_header {
      http_header_name = "X-Canary"
      values           = ["true"]
    }
  }
}
```

### ロールバック戦略

ロールバックの方法を定義します。

```hcl
# 以前のバージョンを保持
resource "aws_launch_template" "web" {
  name_prefix = "web-"
  # ...
  
  lifecycle {
    create_before_destroy = true
  }
}

# スナップショットから復元
resource "aws_ebs_snapshot" "backup" {
  volume_id = aws_ebs_volume.example.id
  
  tags = {
    Name = "backup-${timestamp()}"
  }
}
```

### デプロイ前の検証

デプロイ前に検証を実行します。

```hcl
# 検証用のリソース
resource "aws_instance" "test" {
  ami           = data.aws_ami.amazon_linux.id
  instance_type = "t3.micro"
  
  user_data = <<-EOF
    #!/bin/bash
    # ヘルスチェックスクリプト
    curl -f http://localhost/health || exit 1
  EOF
}
```

## 3-1-4. 環境管理

### 開発環境の管理

開発環境の設定例です。

```hcl
# environments/dev/main.tf
module "infrastructure" {
  source = "../../modules"
  
  environment = "dev"
  instance_type = "t3.micro"
  min_size = 1
  max_size = 2
}
```

### ステージング環境の管理

ステージング環境の設定例です。

```hcl
# environments/staging/main.tf
module "infrastructure" {
  source = "../../modules"
  
  environment = "staging"
  instance_type = "t3.small"
  min_size = 2
  max_size = 4
}
```

### 本番環境の管理

本番環境の設定例です。

```hcl
# environments/prod/main.tf
module "infrastructure" {
  source = "../../modules"
  
  environment = "prod"
  instance_type = "t3.medium"
  min_size = 3
  max_size = 10
}
```

### 環境間の差分管理

環境間の差分を管理します。

```hcl
# terraform.tfvars（環境ごと）
# dev/terraform.tfvars
environment = "dev"
instance_count = 1

# prod/terraform.tfvars
environment = "prod"
instance_count = 5
```

```hcl
# 環境変数で切り替え
variable "environment" {
  type = string
}

locals {
  environment_config = {
    dev = {
      instance_type = "t3.micro"
      min_size      = 1
      max_size      = 2
    }
    prod = {
      instance_type = "t3.medium"
      min_size      = 3
      max_size      = 10
    }
  }
  
  config = local.environment_config[var.environment]
}
```
