# 4-1. Terraformベストプラクティス

Terraformのコードを書く際のベストプラクティスを説明します。

## 4-1-1. コードの可読性

### 一貫したフォーマット（`terraform fmt`）

常に`terraform fmt`を使用してコードを整形します。

```bash
# フォーマットを実行
terraform fmt

# 再帰的にフォーマット
terraform fmt -recursive

# CI/CDでチェック
terraform fmt -check
```

### 意味のある変数名とリソース名

明確で意味のある名前を使用します。

```hcl
# 悪い例
resource "aws_instance" "i1" {
  ami           = "ami-123"
  instance_type = "t3.micro"
}

# 良い例
resource "aws_instance" "web_server" {
  ami           = data.aws_ami.amazon_linux.id
  instance_type = var.instance_type
  
  tags = {
    Name = "web-server-${var.environment}"
  }
}
```

### 適切なコメントの追加

コードの意図を明確にするコメントを追加します。

```hcl
# Webサーバー用のセキュリティグループ
# HTTPとHTTPSのトラフィックを許可
resource "aws_security_group" "web" {
  name        = "web-sg"
  description = "Security group for web servers"
  vpc_id      = aws_vpc.main.id
  
  # HTTPトラフィックを許可
  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
    description = "Allow HTTP from anywhere"
  }
  
  # HTTPSトラフィックを許可
  ingress {
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
    description = "Allow HTTPS from anywhere"
  }
}
```

### ファイルの分割方法

機能ごとにファイルを分割します。

```
project/
├── main.tf              # メインのリソース定義
├── variables.tf         # 変数定義
├── outputs.tf          # 出力値定義
├── versions.tf         # バージョン固定
├── locals.tf           # ローカル変数
├── data.tf             # データソース
├── iam.tf              # IAM関連
├── network.tf          # ネットワーク関連
├── compute.tf          # コンピューティング関連
├── storage.tf          # ストレージ関連
└── terraform.tfvars    # 変数の値
```

### コードの構造化

論理的な順序でリソースを配置します。

```hcl
# 1. プロバイダー設定
terraform {
  required_version = ">= 1.0"
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = var.region
}

# 2. データソース
data "aws_ami" "amazon_linux" {
  most_recent = true
  owners      = ["amazon"]
}

# 3. ローカル変数
locals {
  common_tags = {
    Project     = var.project_name
    Environment = var.environment
    ManagedBy   = "Terraform"
  }
}

# 4. リソース定義
resource "aws_vpc" "main" {
  cidr_block = var.vpc_cidr
  tags       = local.common_tags
}
```

## 4-1-2. 変数の活用

### ハードコードの回避

ハードコードを避け、変数を使用します。

```hcl
# 悪い例
resource "aws_instance" "web" {
  ami           = "ami-0c3fd0f5d33134a76"
  instance_type = "t3.micro"
  subnet_id     = "subnet-12345678"
}

# 良い例
resource "aws_instance" "web" {
  ami           = data.aws_ami.amazon_linux.id
  instance_type = var.instance_type
  subnet_id     = aws_subnet.public.id
}
```

### デフォルト値の設定

適切なデフォルト値を設定します。

```hcl
variable "instance_type" {
  type        = string
  description = "EC2 instance type"
  default     = "t3.micro"
}

variable "environment" {
  type        = string
  description = "Environment name"
  default     = "dev"
}

variable "enable_monitoring" {
  type        = bool
  description = "Enable detailed monitoring"
  default     = false
}
```

### 変数の検証

変数の値を検証します。

```hcl
variable "environment" {
  type        = string
  description = "Environment name"
  
  validation {
    condition     = contains(["dev", "staging", "prod"], var.environment)
    error_message = "Environment must be dev, staging, or prod."
  }
}

variable "instance_type" {
  type        = string
  description = "EC2 instance type"
  
  validation {
    condition     = can(regex("^t3\\.(micro|small|medium)$", var.instance_type))
    error_message = "Instance type must be t3.micro, t3.small, or t3.medium."
  }
}

variable "vpc_cidr" {
  type        = string
  description = "VPC CIDR block"
  
  validation {
    condition     = can(cidrhost(var.vpc_cidr, 0))
    error_message = "VPC CIDR must be a valid IPv4 CIDR block."
  }
}
```

### 環境変数の活用

環境変数を使用して機密情報を管理します。

```bash
# 環境変数で設定
export TF_VAR_db_password="secret_password"
export TF_VAR_api_key="secret_api_key"

# Terraformで使用
terraform apply
```

```hcl
variable "db_password" {
  type        = string
  description = "Database password"
  sensitive   = true
}

variable "api_key" {
  type        = string
  description = "API key"
  sensitive   = true
}
```

### `.tfvars`ファイルの活用

環境ごとに`.tfvars`ファイルを作成します。

```hcl
# dev.tfvars
environment   = "dev"
instance_type = "t3.micro"
min_size      = 1
max_size      = 2

# prod.tfvars
environment   = "prod"
instance_type = "t3.medium"
min_size      = 3
max_size      = 10
```

```bash
# 使用方法
terraform apply -var-file="dev.tfvars"
terraform apply -var-file="prod.tfvars"
```

## 4-1-3. モジュールの活用

### 再利用可能なモジュールの作成

再利用可能なモジュールを作成します。

```hcl
# modules/vpc/main.tf
resource "aws_vpc" "main" {
  cidr_block           = var.vpc_cidr
  enable_dns_hostnames = var.enable_dns_hostnames
  enable_dns_support   = var.enable_dns_support
  
  tags = merge(
    var.tags,
    {
      Name = var.vpc_name
    }
  )
}

# modules/vpc/variables.tf
variable "vpc_cidr" {
  type        = string
  description = "VPC CIDR block"
}

variable "vpc_name" {
  type        = string
  description = "VPC name"
}

variable "enable_dns_hostnames" {
  type        = bool
  description = "Enable DNS hostnames"
  default     = true
}

variable "enable_dns_support" {
  type        = bool
  description = "Enable DNS support"
  default     = true
}

variable "tags" {
  type        = map(string)
  description = "Additional tags"
  default     = {}
}

# modules/vpc/outputs.tf
output "vpc_id" {
  value       = aws_vpc.main.id
  description = "VPC ID"
}

output "vpc_cidr" {
  value       = aws_vpc.main.cidr_block
  description = "VPC CIDR block"
}
```

### モジュールのパラメータ化

モジュールを柔軟にパラメータ化します。

```hcl
# モジュールの使用
module "vpc" {
  source = "./modules/vpc"
  
  vpc_cidr             = "10.0.0.0/16"
  vpc_name             = "main-vpc"
  enable_dns_hostnames = true
  enable_dns_support   = true
  
  tags = {
    Project     = "my-project"
    Environment = "dev"
  }
}
```

### モジュールのバージョン管理

モジュールのバージョンを固定します。

```hcl
# Gitリポジトリからモジュールを使用
module "vpc" {
  source = "git::https://github.com/example/terraform-aws-vpc.git?ref=v1.0.0"
  
  vpc_cidr = "10.0.0.0/16"
}

# Terraform Registryからモジュールを使用
module "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "5.1.2"
  
  name = "my-vpc"
  cidr = "10.0.0.0/16"
}
```

### 公開モジュールの利用

Terraform Registryの公開モジュールを活用します。

```hcl
# VPCモジュール
module "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "5.1.2"
  
  name = "my-vpc"
  cidr = "10.0.0.0/16"
  
  azs             = ["ap-northeast-1a", "ap-northeast-1c"]
  private_subnets = ["10.0.1.0/24", "10.0.2.0/24"]
  public_subnets  = ["10.0.101.0/24", "10.0.102.0/24"]
  
  enable_nat_gateway = true
  enable_vpn_gateway = false
  
  tags = {
    Terraform   = "true"
    Environment = "dev"
  }
}

# RDSモジュール
module "db" {
  source  = "terraform-aws-modules/rds/aws"
  version = "6.3.0"
  
  identifier = "mydb"
  
  engine            = "mysql"
  engine_version    = "8.0"
  instance_class    = "db.t3.micro"
  allocated_storage = 20
  
  db_name  = "mydb"
  username = "admin"
  password = var.db_password
  
  vpc_security_group_ids = [module.security_group.security_group_id]
  
  tags = {
    Environment = "dev"
  }
}
```

## 4-1-4. コメントの書き方

### ドキュメントコメント

リソースの目的を説明するコメントを追加します。

```hcl
# Webアプリケーション用のVPC
# パブリックサブネットとプライベートサブネットを含む
# マルチAZ構成で高可用性を確保
resource "aws_vpc" "main" {
  cidr_block           = "10.0.0.0/16"
  enable_dns_hostnames = true
  enable_dns_support   = true
  
  tags = {
    Name = "main-vpc"
  }
}
```

### 複雑なロジックの説明

複雑なロジックには詳細な説明を追加します。

```hcl
# 環境ごとに異なるインスタンスタイプを選択
# dev: t3.micro, staging: t3.small, prod: t3.medium
locals {
  instance_type = {
    dev     = "t3.micro"
    staging = "t3.small"
    prod    = "t3.medium"
  }[var.environment]
  
  # 本番環境のみマルチAZを有効化
  multi_az = var.environment == "prod" ? true : false
}
```

### TODOコメント

将来の改善点をTODOコメントで記録します。

```hcl
resource "aws_instance" "web" {
  ami           = data.aws_ami.amazon_linux.id
  instance_type = var.instance_type
  
  # TODO: IAMロールを追加してS3アクセスを許可
  # TODO: ユーザーデータでアプリケーションを自動デプロイ
  
  tags = {
    Name = "web-server"
  }
}
```

### 非推奨の明示

非推奨のリソースや設定を明示します。

```hcl
# DEPRECATED: Classic Load Balancerは非推奨
# Application Load Balancerへの移行を推奨
resource "aws_elb" "legacy" {
  name               = "legacy-elb"
  availability_zones = ["ap-northeast-1a"]
  
  # ...
}
```

## 4-1-5. エラーハンドリング

### バリデーションの追加

入力値の検証を追加します。

```hcl
variable "cidr_block" {
  type        = string
  description = "CIDR block for VPC"
  
  validation {
    condition     = can(cidrhost(var.cidr_block, 0))
    error_message = "CIDR block must be a valid IPv4 CIDR."
  }
}

variable "instance_count" {
  type        = number
  description = "Number of instances"
  
  validation {
    condition     = var.instance_count >= 1 && var.instance_count <= 10
    error_message = "Instance count must be between 1 and 10."
  }
}
```

### エラーメッセージの改善

わかりやすいエラーメッセージを提供します。

```hcl
variable "environment" {
  type        = string
  description = "Environment name"
  
  validation {
    condition     = contains(["dev", "staging", "prod"], var.environment)
    error_message = <<-EOT
      Invalid environment: ${var.environment}
      Valid values are: dev, staging, prod
      Example: terraform apply -var="environment=dev"
    EOT
  }
}
```

### 失敗時の挙動の設計

リソース作成失敗時の挙動を設計します。

```hcl
resource "aws_instance" "web" {
  ami           = data.aws_ami.amazon_linux.id
  instance_type = var.instance_type
  
  # インスタンスが削除される前に新しいインスタンスを作成
  lifecycle {
    create_before_destroy = true
  }
  
  # 特定の属性の変更を無視
  lifecycle {
    ignore_changes = [
      ami,
      user_data
    ]
  }
}
```

## 4-1-6. パフォーマンス

### 並列実行の最適化

並列実行を最適化します。

```bash
# 並列実行数を指定
terraform apply -parallelism=20

# デフォルトは10
```

### 依存関係の最適化

不要な依存関係を避けます。

```hcl
# 悪い例: 明示的な依存関係が多すぎる
resource "aws_instance" "web" {
  depends_on = [
    aws_vpc.main,
    aws_subnet.public,
    aws_security_group.web
  ]
}

# 良い例: 暗黙的な依存関係を使用
resource "aws_instance" "web" {
  subnet_id              = aws_subnet.public.id
  vpc_security_group_ids = [aws_security_group.web.id]
  # 依存関係は自動的に解決される
}
```

### データソースの効率的な使用

データソースを効率的に使用します。

```hcl
# 悪い例: 毎回データソースを取得
resource "aws_instance" "web1" {
  ami = data.aws_ami.amazon_linux.id
}

resource "aws_instance" "web2" {
  ami = data.aws_ami.amazon_linux.id
}

# 良い例: データソースを一度取得してlocalsで共有
data "aws_ami" "amazon_linux" {
  most_recent = true
  owners      = ["amazon"]
}

locals {
  ami_id = data.aws_ami.amazon_linux.id
}

resource "aws_instance" "web1" {
  ami = local.ami_id
}

resource "aws_instance" "web2" {
  ami = local.ami_id
}
```
